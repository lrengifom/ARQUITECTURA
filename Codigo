CONDICIONES_INICIALES: MOV ACC, CTE #CARGAR DIRECCIÓN DE VARa EN ACC
VARa
MOV DPTR, ACC #COPIAR DIRECCIÓN DE VARa EN DPTR
MOV ACC, CTE #ALMACENAR EN ACC 00000000
0x00
MOV [DPTR], ACC #GUARDAR EN VARa 00000000
MOV ACC, CTE #CARGAR DIRECCIÓN DE qsub1 EN ACC
qsub1
MOV DPTR, ACC #COPIAR EN DPTR LA DIRECCIÓN DE qsub1
MOV ACC, CTE #ALMACENAR EN qsub1 00000000
0x00
MOV [DPTR], ACC #GUARDAR EN qsub1 00000000
MOV ACC, CTE #CARGAR DIRECCIÓN DE Count EN ACC
Count
MOV DPTR, ACC #COPIAR DIRECCIÓN DE Count EN DPTR
MOV ACC, CTE #ALMACENAR EN ACC 8 (NÚMERO DE ITERACIONES QUE VA A TENER QUE HACER)
0x08 #EN BINARIO: 00001000
MOV [DPTR], ACC #ALMACENAR EN Count LO QUE ESTÁ EN ACC (8)
LOOP: MOV ACC, CTE #CARGAR DIRECCIÓN DE Count EN ACC
Count
MOV DPTR, ACC #COPIAR DIRECCIÓN DE Count EN DPTR
MOV ACC, [DPTR] #COPIAR EN ACC EL CONTENIDO DE LA Count
BAN
JZ CTE #ver si continua, si Count es igual a 0 entonces ya ha terminado, si no, continuacon el programa de forma normal
END_LOOP
JMP CTE
OBTENER_QSub0
OBTENER_QSub0: MOV ACC, CTE #CARGAR DIRECCIÓN DE varQ A ACC
varQ
MOV DPTR, ACC #COPIAR DIRECCIÓN DE varQ A DPTR
MOV ACC, [DPTR] #COPIAR CONTENIDO DE varQ A ACC
MOV A, ACC #COPIAR varQ en A
JMP CTE
MOV ACC, CTE #ALMACENAR EN REGISTRO ACUMULADOR 00X1
0x01
AND ACC, A #AND ENTRE varQ Y 00X1: SI RESULTADO ES 0, QSUB0 ES 0, CASO CONTRARIO ES 1
SLL ACC #SHIFT HACIA LA IZQUIERDA DEL RESULTADO
MOV A, ACC #COPIAR RESULTADO EN A
MOV ACC, CTE #CARGAR DIRECCIÓN DE qsub1 EN ACC
qsub1
MOV DPTR, ACC #COPIAR DIRECCIÓN DE varQ EN DPTR
MOV ACC, [DPTR] #COPIAR VALOR DE varQ EN ACC
MOV A, A #SUMA DE 000000(Q0)0 Y qsub1, LOS RESULTADOS POSIBLES SON 11, 00, 10, 01

ADD ACC, A #SUMA DE 000000(Q0)0 Y qsub1, LOS RESULTADOS POSIBLES SON 11, 00, 10, 01
EVALUAR_CASO: BAN
JZ CTE #SI RESULTADO ES 00, IR A CORRIMIENTOS DIRECTAMENTE
CORRIMIENTOS
MOV A, ACC #COPIAR EL RESULTADO en A
MOV ACC, CTE #ALMACENAR EN ACC EL COMPLEMENTO A 2 DE 00000011
0xFD #11111101
ADD ACC, A #SUMAR RESULTADO DE SUMA CON COMPLEMENTO A 2 DE 00X11
BAN
JZ CTE #SI RESULTADO ES 00000000 (Q0 Y Q-1: 11) ENTONCES SALTAR A CORRIMIENTOS
CORRIMIENTOS
INV ACC #SI Q0 Q-1 ES 00000010 ENTONCES SUMARLE EL COMPLEMENTO A 2 DE 00000011 VA A DAR 11111111 Y SU INVERSO SERÁ 00000000
BAN
JZ CTE #EN CASO DE QUE AL NEGAR LA SUMA EL RESULTADO SEA 00000000 SALTAR A CASO_10
CASO_10
JMP CTE #DE LO CONTRARIO SALTAR A CASO_01
CASO_01
CASO_10: MOV ACC, CTE #CARGAR LA DIRECCIÓN DE varM en ACC
varM
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE varM EN DPTR
MOV ACC, [DPTR] #COPIAR EL CONTENIDO DE varM EN ACC
INV ACC #NEGAR EL CONTENIDO DE varM
MOV A, ACC #COPIAR LA NEGACIÓN DE varM EN A
MOV ACC, CTE #CARGAR EN ACC 00000001
0x01
ADD ACC, A #SUMAR 1 A LA NEGACIÓN DE varM (RESULTADO: COMPLEMENTO A DOS DE varM O (-varM))
MOV A, ACC #COPIAR COMPLEMENTO A DOS DE varM EN A
MOV ACC, CTE #CARGAR LA DIRECCIÓN DE VARa EN ACC
VARa
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE VARa EN DPTR
MOV ACC, [DPTR] #COPIAR CONTENIDO DE VARa EN ACC
ADD ACC, A #RESTAR A VARa varM
MOV [DPTR], ACC #ALMACENAR RESULTADO DEVUELTA EN VARa
JMP CTE #Volver a corrimientos al finalizar
CORRIMIENTOS
CASO_01: MOV ACC, CTE #CARGAR LA DIRECCIÓN DE varM EN ACC
varM
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE varM EN DPTR
MOV ACC, [DPTR] #COPIAR EL VALOR DE varM EN ACC
MOV A, ACC #COPIAR EL VALOR DE varM EN A
MOV ACC, CTE #CARGAR LA DIRECCIÓN DE VARa EN ACC
VARa
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE VARa EN DPTR
MOV ACC, [DPTR] #COPIAR EL CONTENIDO DE VARa EN ACC
ADD ACC, A #SUMAR VARa Y varM
MOV [DPTR], ACC #ALMACENAR RESULTADO DE LA SUMA DE VUELTA EN VARa
JMP CTE #Volver a corrimientos al finalizar
CORRIMIENTOS
CORRIMIENTOS: MOV ACC, CTE #CARGAR LA DIRECCIÓN DE varQ EN ACC (PARA OBTENER QSUB0 QUE VA A PASAR A SER Q-1)
varQ
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE varQ EN DPTR
MOV ACC, [DPTR] #COPIAR EL CONTENIDO DE varQ EN ACC
MOV A, ACC #COPIAR EL CONTENIDO DE varQ EN A
MOV ACC, CTE #CARGA 00000001 EN ACC
0x01
AND ACC, A
MOV A, ACC #MOVER QSUB0 QUE VA A PASAR A SER Q-1 EN A
MOV ACC, CTE #CARGAR LA DIRECCIÓN DE qsub1 EN ACC
qsub1
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE qsub1 EN DPTR
MOV ACC, A #COPIAR EN ACC EL RESULTADO DE LA AND (00000000 O 00000001)
MOV [DPTR], ACC #ALMACENAR EN qsub1 EL RESULTADO DE LA AND
MOV ACC, CTE
VARa
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE VARa EN DPTR
MOV ACC, [DPTR] #COPIAR EL CONTENIDO DE VARa EN ACC
MOV A, ACC #COPIAR EL CONTENIDO DE VARa EN A
MOV ACC, CTE #ALMACENAR EN ACC 00000001
0x01
AND ACC, A
BAN
JZ CTE
CORRIMIENTOS_NOCARRY
JMP CTE
CORRIMIENTOS_CARRY
CORRIMIENTOS_NOCARRY: MOV ACC, CTE
varQ
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE LA varQ EN DPTR
MOV ACC,[DPTR] #COPIAR EL VALOR DE varQ EN ACC
SRL ACC #HACER UN CORRIMIENTO LÓGICO HACIA LA DERECHA DE varQ
MOV [DPTR], ACC #ALMACENAR varQ LUEGO DEL CORRIMIENTO EN varQ
JMP CTE
CORRIMIENTOS_VA A LA FUNCIÓN DE CORRIMIENTOS
CORRIMIENTOS_CARRY: MOV ACC, CTE
varQ #CARGAR LA DIRECCIÓN DE varQ A ACC
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE varQ A DPTR
MOV ACC,[DPTR] #COPIAR EL CONTENIDO DE varQ A ACC
SRL ACC #HACER CORRIMIENTO LÓGICO A DERECHA DE EL CONTENIDO DE varQ
MOV A, ACC #COPIAR RESULTADO DEL CORRIMIENTO A A
MOV ACC, CTE #CARGAR EN ACC 10000000 (DIGITO DE CARRY QUE LLEGA DE A)
0x80
ADD ACC, A #SUMAR EL CORRIMIENTO DE varQ CON 10000000
MOV [DPTR], ACC #ALMACENAR DE VUELTA EN varQ EL RESULTADO
JMP CTE
CORRIMIENTOS_VA A LA FUNCIÓN DE CORRIMIENTOS
CORRIMIENTOS: MOV ACC, CTE #CARGAR LA DIRECCIÓN DE VARa EN ACC
VARa
MOV DPTR, ACC #COPIAR LA DIRECCIÓN DE VARa EN DPTR
MOV ACC, [DPTR] #COPIAR EL CONTENIDO DE VARa EN ACC
MOV A, ACC #COPIAR EL CONTENIDO DE VARa EN A
MOV ACC, CTE
0x80
AND ACC, A #AND ENTRE EL CONTENIDO DE VARa Y 10000000
MOV A, ACC #ALMACENA EL RESULTADO DE LA AND EN A
MOV ACC, CTE #VUELVE A CARGAR VARa EN ACC
VARa
MOV DPTR, ACC
MOV ACC, [DPTR]
SRL ACC #SE REALIZA EL CORRIMIENTO LÓGICO A DERECHA DE VARa
ADD ACC, A
MOV [DPTR], ACC #SE ALMACENA EL RESULTADO EN VARa
MOV ACC, CTE #CARGA LA DIRECCIÓN DE Count EN ACC
Count
MOV DPTR, ACC #COPIA LA DIRECCIÓN DE Count EN DPTR
MOV ACC, [DPTR] #COPIA EL CONTENIDO DE Count EN ACC
MOV A, ACC #COPIA EL CONTENIDO DE Count EN A
MOV ACC, CTE #ALMACENA EN ACC 11111111 (COMPLEMENTO A 2 DE 00000001)
0xFF
ADD ACC, A #SE RESTA UNO A Count (SUMÁNDOLE -1)
MOV A, ACC #SE ALMACENA RESULTADO (Count-1) EN A
MOV ACC, CTE #SE CARGA LA DIRECCIÓN DE Count EN DPTR DE NUEVO
Count
MOV DPTR, ACC
MOV ACC, A #SE COPIA EN ACC Count-1
MOV [DPTR], ACC #ALMACENA EN Count EL NUEVO VALOR DEL CONTADOR
JMP CTE
LOOP #SE VUELVE AL INICIO DEL CICLO
END_LOOP: MOV ACC, CTE
VARa
MOV DPTR, ACC
MOV ACC, [DPTR]
MOV A, ACC
MOV ACC, CTE
varQ
MOV DPTR, ACC
MOV ACC, [DPTR]
HALT
VARa: 0x00
qsub1: 0x00
varM: 0x00 #MULTIPLICANDO
varQ: 0x00 #M
Count: 0x00

MOV ACC,A 0b00001000
MOV A, ACC 0b00010000
MOV ACC, CTE 0b00011000
MOV ACC, [DPTR] 0b00100000
MOV DPTR, ACC 0b00101000
MOV [DPTR], ACC 0b00110000
INV ACC 0b00111000
AND ACC, A 0b01000000
ADD ACC, A 0b01001000
JMP DIR 0b01010000
JZ DIR 0b01011000
JN DIR 0b01100000
JC DIR 0b01101000
SLL ACC 0b10000000
SRL ACC 0b10001000
BAN ACC 0b10010000
HALT 0b11111000
VARa:0b10110010
qsub1: 0b10110011
varM:0b10110100
varQ:0b10110101
Count: 0b10110110
LOOP:0b00010010
Obtener_QSUB0: 0b00011011
CORRIMIENTOS: 0b01011001
CASO_10: 0b00111010
CASO_01: 0b01001100
CORRIMIENTOS_NOCARRY: 0b01110100
CORRIMIENTOS_CARRY: 0b01111100
CORRIMIENTOS: 0b10001000
END_LOOP: 0b10101000
